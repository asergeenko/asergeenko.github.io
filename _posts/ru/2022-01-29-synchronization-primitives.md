---
title: Примитивы синхронизации в Python
#permalink: /synchronization-primitives-in-python/
lang: ru
---
# Примитивы синхронизации в Python
- [Lock](#lock)
- [RLock](#rlock)
- [Semaphore](#semaphore)
- [Bounded Semaphore](#bounded-semaphore)
- [Event](#event)
- [Condition](#condition)
## Зачем?
- синхронизация потоков (thread synchronization)
- совместно используемые данные (shared data)
- порядок выполнения / состояние гонки (race condition) - повреждение совместно используемых данных[^1]

## Но ведь есть asyncio?
Многопоточность (и многопроцессорность) использует *вытесняющую многозадачность*, следующая задача начинает выполняться при наступлении определённых событий или по прошествии определённого времени.

Недостаток: непонятно, когда наступит переключение
- 1 задача: Сейчас налево, а через 100 метров повернуть на улицу Пе...[*переключение*]
- 2 задача: 343*2 + ...[*переключение*]

Asyncio же использует *кооперативную многозадачность* - следующая задача выполняется, когда предыдующая явно подаёт сигнал об этом (мы должны указать это в коде). В этом случае мы точно знаем, в какой момент происходит переключение.

## I/O bound vs CPU bound
Разобраться в типе задачи помогает диаграмма (нарисовать).

## Lock
Мьютекс (mutex - mutual exclusion - взаимное исключение) - только один поток может иметь доступ к совместно используемым данным в данный момент времени.
~~~
m.acquire() # Заблокировать
-------------------------------------------------------------
Критическая секция - работа с совместно используемыми данными
-------------------------------------------------------------
m.release() # Разблокировать
~~~
Весь код, изменяющий совместно используемые данные, должен быть помещён в критические секции. Это ответственность программиста.

## RLock
## Semaphore
## Bounded Semaphore
## Event
## Condition

[^1]: https://www.dabeaz.com/usenix2009/concurrent/Concurrent.pdf

