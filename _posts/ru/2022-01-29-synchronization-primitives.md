---
title: Примитивы синхронизации в Python
#permalink: /synchronization-primitives-in-python/
lang: ru
---
# Примитивы синхронизации в Python
- [Lock](#lock)
- [RLock](#rlock)
- [Semaphore](#semaphore)
- [Bounded Semaphore](#bounded-semaphore)
- [Event](#event)
- [Condition](#condition)
## Зачем?
*Метафора: голова человека и задачи в ней. Для многопроцессорности: голова дракона.*

- синхронизация потоков (thread synchronization)
- совместно используемые данные (shared data)
- порядок выполнения / состояние гонки (race condition) - повреждение совместно используемых данных


## Но ведь есть asyncio?
Многопоточность (и многопроцессорность) использует *вытесняющую многозадачность*, следующая задача начинает выполняться при наступлении определённых событий или по прошествии определённого времени.

Недостаток: непонятно, когда наступит переключение
- 1 задача: Сейчас налево, а через 100 метров повернуть на улицу Пе...[*переключение*]
- 2 задача: 343*2 + ...[*переключение*]

Asyncio же использует *кооперативную многозадачность* - следующая задача выполняется, когда предыдующая явно подаёт сигнал об этом (мы должны указать это в коде). В этом случае мы точно знаем, в какой момент происходит переключение.

## I/O bound vs CPU bound
Разобраться в типе задачи помогает диаграмма (нарисовать).

## Lock
Мьютекс (mutex - mutual exclusion - взаимное исключение) - только один поток может иметь доступ к совместно используемым данным в данный момент времени.
~~~
import threading
m = threading.Lock()
m.acquire() # Заблокировать
#############################################################
Критическая секция - работа с совместно используемыми данными
#############################################################
m.release() # Разблокировать
~~~
Весь код, изменяющий совместно используемые данные, должен быть помещён в критические секции. Это ответственность программиста, и отслеживать все критические секции неудобно. Нужно не забывать снимать блокировку (вызов ```release()``` в finally-блоке обработки исключений или помещать критическую секцию в ```with```) после каждого захвата.
Не пишите код, который делает более одной блокировки одновременно (например, вложенный with)[^1] Это может закончиться взаимной блокировкой (deadlock).
*Придумать метафору и нарисовать взаимную блокировку*


## RLock
Reentrant mutex lock - повторно используемая блокировка. Отличие от Lock - **один и тот же поток** может рекурсивно захватывать блокировку несколько раз без разблокировки (но обязательно освобождать после использования). 

## Semaphore
Семафор - блокировка с счётчиком.
~~~
m = threading.Semaphore(n) # n - значение счётчика
m.acquire() # если счётчик > 0 - уменьшает значение счётчика на 1 и продолжает выполнение,
            # иначе ждёт, пока счётчик не станет = 0
m.release() # увеличивает значение счётчика на 1 и уведомляет об этом ожидающие потоки (если они есть)
~~~

В отличие от мьютекса, ```acquire()``` и ```release()``` вызываются в любом порядке.

Использование:
### контроль ресурсов
Можно ограничить количество потоков, выполняющих определённые операции (запросы к базе данных, сетевые соединения и т.п.).

В примере ниже[^1] одновременно может выполняться не более пяти потоков, в противном случае они ждут своей очереди.
~~~
sema = threading.Semaphore(5)
def fetch_page(url):
    sema.acquire()
    try:
        u = urllib.urlopen(url)
        return u.read()
    finally:
        sema.release()
~~~
### сигналы потоков друг другу
Семафор можно использовать для передачи сигналов между потоками.

В примере ниже[^1] ```acquire()``` и ```release()``` выполняются в разных потоках и в "неправильном" порядке. Такая техника используется в архитектуре *producer - consumer*.
~~~
done = threading.Semaphore(0)
~~~
| Поток 1              | Поток 2                 |
| -------------------- | ----------------------- |
| ...                  | **done.acquire()**      |
| оператор             | оператор                |
| оператор             | оператор                |
| оператор             | оператор                |
| **done.release()**   | ...                     |

## Bounded Semaphore
То же, что и обычный семафор, но при вызове ```release()``` проверяет, чтобы значение счётчика было не больше, чем его первоначальное значение. В противном случае вызывается исключение ```ValueError```

## Event
~~~
event = threading.Event()
~~~
Блокировка потока до наступления события (установки флага). 
Методы:
- ```is_set()``` - возвращает ```True```, если флаг события установлен
- ```set()``` - устанавливает флаг события и разблокирует все потоки, ожидающие выполнения события
- ```clear()``` - сбрасывает флаг события
- ```wait()``` - **блокирует** выполнение потока, пока флаг события не будет установлен 

## Condition

[^1]: https://www.dabeaz.com/usenix2009/concurrent/Concurrent.pdf

