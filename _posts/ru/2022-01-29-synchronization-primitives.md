---
title: Примитивы синхронизации в Python
#permalink: /synchronization-primitives-in-python/
lang: ru
---
# Примитивы синхронизации в Python
- [Lock](#lock)
- [RLock](#rlock)
- [Semaphore](#semaphore)
- [Bounded Semaphore](#bounded-semaphore)
- [Event](#event)
- [Condition](#condition)
- [Barrier](#barrier)
## Зачем?
*Метафора: голова человека и задачи в ней. Для многопроцессорности: голова дракона.*

- синхронизация потоков (thread synchronization)
- совместно используемые данные (shared data)
- порядок выполнения / состояние гонки (race condition) - повреждение совместно используемых данных


## Но ведь есть asyncio?
Многопоточность (и многопроцессорность) использует *вытесняющую многозадачность*, следующая задача начинает выполняться при наступлении определённых событий или по прошествии определённого времени.

Недостаток: непонятно, когда наступит переключение
- 1 задача: Сейчас налево, а через 100 метров повернуть на улицу Пе...[*переключение*]
- 2 задача: 343*2 + ...[*переключение*]

Asyncio же использует *кооперативную многозадачность* - следующая задача выполняется, когда предыдующая явно подаёт сигнал об этом (мы должны указать это в коде). В этом случае мы точно знаем, в какой момент происходит переключение.

## I/O bound vs CPU bound
Разобраться в типе задачи помогает диаграмма (нарисовать).

## Lock
Мьютекс (mutex - mutual exclusion - взаимное исключение) - только один поток может иметь доступ к совместно используемым данным в данный момент времени.
~~~
import threading
m = threading.Lock()
m.acquire() # Заблокировать
#############################################################
Критическая секция - работа с совместно используемыми данными
#############################################################
m.release() # Разблокировать
~~~
Весь код, изменяющий совместно используемые данные, должен быть помещён в критические секции. Это ответственность программиста, и отслеживать все критические секции неудобно. Нужно не забывать снимать блокировку (вызов ```release()``` в finally-блоке обработки исключений или помещать критическую секцию в ```with```) после каждого захвата.
Не пишите код, который делает более одной блокировки одновременно (например, вложенный with)[^1] Это может закончиться взаимной блокировкой (deadlock).
*Придумать метафору и нарисовать взаимную блокировку*


## RLock
Reentrant mutex lock - повторно используемая блокировка. Отличие от Lock - **один и тот же поток** может рекурсивно выполнять захват несколько раз без освобождения (но обязательно освобождать ресурс после использования). 

## Semaphore
Семафор - захват со счётчиком.
~~~
m = threading.Semaphore(n) # n - значение счётчика
m.acquire() # если счётчик > 0 - уменьшает значение счётчика на 1 и продолжает выполнение,
            # иначе ждёт, пока счётчик не станет = 0
m.release() # увеличивает значение счётчика на 1 и уведомляет об этом ожидающие потоки (если они есть)
~~~

В отличие от мьютекса, ```acquire()``` и ```release()``` вызываются в любом порядке.

Использование:
### контроль ресурсов
Можно ограничить количество потоков, выполняющих определённые операции (запросы к базе данных, сетевые соединения и т.п.).

В примере ниже[^1] одновременно может выполняться не более пяти потоков, в противном случае они ждут своей очереди.
~~~
sema = threading.Semaphore(5)
def fetch_page(url):
    sema.acquire()
    try:
        u = urllib.urlopen(url)
        return u.read()
    finally:
        sema.release()
~~~
### сигналы потоков друг другу
Семафор можно использовать для передачи сигналов между потоками.

В примере ниже[^1] ```acquire()``` и ```release()``` выполняются в разных потоках и в "неправильном" порядке. Такая техника используется в архитектуре *producer - consumer*.
~~~
done = threading.Semaphore(0)
~~~
| Поток 1              | Поток 2                 |
| -------------------- | ----------------------- |
| ...                  | **done.acquire()**      |
| оператор             | оператор                |
| оператор             | оператор                |
| оператор             | оператор                |
| **done.release()**   | ...                     |

## Bounded Semaphore
То же, что и обычный семафор, но при вызове ```release()``` проверяет, чтобы значение счётчика было не больше, чем его первоначальное значение. В противном случае вызывается исключение ```ValueError```

## Event
Блокировка потока до наступления события (установки флага).
~~~
event = threading.Event()
~~~
Методы:

- ```is_set()``` - возвращает ```True```, если флаг события установлен
- ```set()``` - устанавливает флаг события и разблокирует все потоки, ожидающие выполнения события
- ```clear()``` - сбрасывает флаг события
- ```wait()``` - **блокирует** выполнение потока, пока флаг события не будет установлен 

Использование:

- **уведомления** - сообщить, что что-то произошло (инициализация, успешное выполнение задания т.п.)

## Condition

Комбинация захвата и уведомления. Захватывает критическую секцию и уведомляет об этом остальные потоки.
~~~
cv = threading.Condition(lock=None)
~~~
```lock``` - объект [Lock](#lock) или [RLock](#rlock) (если не указан, создаётся новый)

Методы:
- ```acquire()```
- ```release()```
- ```wait(timeout=None)``` - вызывает ```release()``` и блокирует поток до вызова другим потоком ```notify()``` или ```notify_all()``` или истечения времени ```timeout```, после разблокировки опять захватывает ```lock``` . Перед вызовом метода обязателен вызов ```acquire()```
- ```wait_for(predicate, timeout=None)``` - повторно вызывает ```wait()``` до тех пор, пока ```predicate``` не вернёт ```True```. Перед вызовом метода обязаетелен вызов ```acquire()```
- ```notify(n=1)``` - разблокирует ```n``` ожидающих потоков
- ```notify_all()``` - разблокирует все ожидающие потоки. Если вызывающий поток не захватил ```lock```, вызывается исключение RuntimeError

Пример[^1]:

~~~
items = []
items_cond = threading.Condition()
~~~

| Поток **Producer**      | Поток **Consumer**      |
| ----------------------- | ----------------------- |
| <pre>item = produce_item()<br>with cond:<br>&nbsp;&nbsp;&nbsp;&nbsp;items.append(item)<br>&nbsp;&nbsp;&nbsp;&nbsp;**cond.notify()**</pre> | <pre>with cond:<br>&nbsp;&nbsp;&nbsp;&nbsp;while not items:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**cond.wait()**<br>&nbsp;&nbsp;&nbsp;&nbsp;x = items.pop(0)<br># Что-то делаем с x</pre>|

## Barrier

**Барьер** - потоки, дойдя до барьера должны дождаться остальных и только тогда выполняться дальше. Когда один из потоков вызывает ```wait()```, он блокируется и ждёт, пока все потоки (число указывается при создании барьера) не вызовут ```wait()```, после чего все потоки продолжают выполняться. 

~~~
barrier = Barrier(5, timeout=None, action=call_after_release)
~~~
```action``` - вызывается **одним** из потоков после освобождения

Методы:

- ```wait(timeout=None)``` - блокирует поток до вызова ```wait()``` всеми потоками или пока не пройдёт время ```timeout```
- ```reset()``` - возвращает барьер к первоначальному состоянию
- ```abort()``` - после вызова метода любая попытка вызова ```wait()``` приведёт к вызову исключения ```BrokenBarrierError```. Используется при прерывании одного из потоков для предотвращения взаимной блокировки. 
- 
[^1]: https://www.dabeaz.com/usenix2009/concurrent/Concurrent.pdf


### Ссылки
- [
An Introduction to Python Concurrency](https://www.dabeaz.com/usenix2009/concurrent/Concurrent.pdf)
- https://docs.python.org/3/library/threading.html

