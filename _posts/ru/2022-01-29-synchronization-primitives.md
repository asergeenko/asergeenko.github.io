---
title: Примитивы синхронизации в Python
#permalink: /synchronization-primitives-in-python/
lang: ru
---
# Примитивы синхронизации в Python
- [Lock](#lock)
- [RLock](#rlock)
- [Semaphore](#semaphore)
- [Bounded Semaphore](#bounded-semaphore)
- [Event](#event)
- [Condition](#condition)
## Зачем?
*Метафора: голова человека и задачи в ней. Для многопроцессорности: голова дракона.*

- синхронизация потоков (thread synchronization)
- совместно используемые данные (shared data)
- порядок выполнения / состояние гонки (race condition) - повреждение совместно используемых данных


## Но ведь есть asyncio?
Многопоточность (и многопроцессорность) использует *вытесняющую многозадачность*, следующая задача начинает выполняться при наступлении определённых событий или по прошествии определённого времени.

Недостаток: непонятно, когда наступит переключение
- 1 задача: Сейчас налево, а через 100 метров повернуть на улицу Пе...[*переключение*]
- 2 задача: 343*2 + ...[*переключение*]

Asyncio же использует *кооперативную многозадачность* - следующая задача выполняется, когда предыдующая явно подаёт сигнал об этом (мы должны указать это в коде). В этом случае мы точно знаем, в какой момент происходит переключение.

## I/O bound vs CPU bound
Разобраться в типе задачи помогает диаграмма (нарисовать).

## Lock
Мьютекс (mutex - mutual exclusion - взаимное исключение) - только один поток может иметь доступ к совместно используемым данным в данный момент времени.
~~~
import threading
m = threading.Lock()
m.acquire() # Заблокировать
#############################################################
Критическая секция - работа с совместно используемыми данными
#############################################################
m.release() # Разблокировать
~~~
Весь код, изменяющий совместно используемые данные, должен быть помещён в критические секции. Это ответственность программиста, и отслеживать все критические секции неудобно. Нужно не забывать снимать блокировку (вызов release() в finally-блоке обработки исключений или помещать критическую секцию в with) после каждого захвата.
Не пишите код, который делает более одной блокировки одновременно (например, вложенный with)[^1] Это может закончиться взаимной блокировкой (deadlock).
*Придумать метафору и нарисовать взаимную блокировку*


## RLock
Reentrant mutex lock - повторно используемая блокировка. Отличие от Lock - **один и тот же поток** может рекурсивно захватывать блокировку несколько раз без разблокировки (но обязательно освобождать после использования). 

## Semaphore
Семафор - блокировка с счётчиком.
~~~
m = threading.Semaphore(n) # n - значение счётчика
m.acquire() # если счётчик > 0 - уменьшает значение счётчика на 1 и продолжает выполнение,
            # иначе ждёт, пока счётчик не станет = 0
m.release() # увеличивает значение счётчика на 1 и уведомляет об этом ожидающие потоки (если они есть)
~~~

В отличие от мьютекса, acquire() и release() вызываются в любом порядке.

## Bounded Semaphore
## Event
## Condition

[^1]: https://www.dabeaz.com/usenix2009/concurrent/Concurrent.pdf

